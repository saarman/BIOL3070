---
title: "Wk3 - Bloodmeal Dataset"
author: "Norah Saarman"
date: "Sep 9, 2025"
output:
  github_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

All data available, pip and tars Uniting WNV and Bloodmeal COi Sequences

# Bloodmeal COi Sequences

```{r blood}
blood_raw <- read.csv("./data/bloodmeal_for_BIOL3070.csv", stringsAsFactors = FALSE)

blood <- data.frame(
  date           = as.Date(blood_raw$Collection.Date, 
                           tryFormats = c("%Y-%m-%d","%m/%d/%Y")),
  year           = blood_raw$year,
  month          = blood_raw$month,
  lat            = blood_raw$Lat,
  long           = blood_raw$Long,
  loc_name       = blood_raw$Location,
  loc_code       = blood_raw$site_code,
  loc_year = sub("\\..*$", "", blood_raw$loc_year_month),
  mosq_species   = blood_raw$mosq_species,
  host_species   = blood_raw$host_species,
  host_common   = blood_raw$host_common,
  host_method   = blood_raw$host_method,
  BIOL3070_seqID = blood_raw$SEQ..BIOL3070
)

# Drop Cx_erythrothorax
blood <- subset(blood, mosq_species != "Cx_erythrothorax")

head(blood)
```

# WNV test status by mosquito pool

```{r pools}
pools_raw <- read.csv("./data/mosquito_pools_WNV.csv", stringsAsFactors = FALSE)

pools <- data.frame(
  agency_pool_num = pools_raw$agency_pool_num,
  mosq_species    = pools_raw$mosq_species,
  num_count       = pools_raw$num_count,
  date            = as.Date(pools_raw$collection_date, 
                            tryFormats = c("%Y-%m-%d","%m/%d/%Y")),
  year            = pools_raw$year,
  month           = pools_raw$month,
  lat             = pools_raw$longitude,
  long            = pools_raw$latitude,
  loc_code        = pools_raw$site_code,
  loc_name        = pools_raw$site_name,
  loc_year = sub("\\..*$", "", pools_raw$loc_year_month),
  test_status     = pools_raw$test_status
)

# Drop Cx_erythrothorax
pools <- subset(pools, mosq_species != "Cx_erythrothorax")

head(pools)
```

# Overlap by loc_year + mosq_species

```{r}
# Inner join by loc_year + mosq_species
overlap <- merge(
  blood,
  pools,
  by = c("loc_year", "mosq_species")
)

head(overlap); str(overlap); nrow(overlap)
```

## Taxonomy

```{r}
# Add taxonomy to table
library(taxize)
overlap$species <- gsub("_", " ", overlap$host_species)
species_names <- unique(overlap$species)

get_tax <- function(sp) {
  x <- try(classification(sp, db = "gbif")[[1]], silent = TRUE)
  if (inherits(x, "try-error") || is.null(x)) return(NULL)
  x$rank <- tolower(x$rank)
  pick <- function(rk) {
    v <- x$name[x$rank == rk]
    if (length(v) > 0) v[1] else NA
  }
  data.frame(
    species = sp,
    genus   = pick("genus"),
    family  = pick("family"),
    order   = pick("order"),
    class   = pick("class"),
    stringsAsFactors = FALSE
  )
}

tax_table <- do.call(rbind, lapply(species_names, get_tax))

# join back to overlap
overlap <- merge(overlap, tax_table, by = "species", all.x = TRUE)
head(overlap[c("host_species","species","genus","family","order","class")])

# Write to file
write.csv(overlap, "./data/overlap_bloodmeal_WNV_byYear_pip_tar.csv", row.names = FALSE)
```

# Collapse to counts

Host species, and counts of confirmed/negative WNV pools by
loc_year × mosq_species.

## Narrow format only one host_species column...

```{r counts}
## 1) Bloodmeal counts: host species per key
host_counts <- aggregate(
  x = list(n_bloodmeals = rep(1, nrow(blood))),
  by = list(
    loc_year = blood$loc_year,
    mosq_species   = blood$mosq_species,
    host_common   = blood$host_common
  ),
  FUN = sum
)

## 2) WNV pool counts: test status per key
pool_counts_long <- aggregate(
  x = list(n_pools = rep(1, nrow(pools))),
  by = list(
    loc_year = pools$loc_year,
    mosq_species   = pools$mosq_species,
    test_status    = pools$test_status
  ),
  FUN = sum
)

## 3) Make Confirmed/Negative columns (keep both; fill missing with 0)
pc_conf <- subset(pool_counts_long, test_status == "Confirmed")[, c("loc_year","mosq_species","n_pools")]
names(pc_conf)[3] <- "pools_confirmed"

pc_neg  <- subset(pool_counts_long, test_status == "Negative")[, c("loc_year","mosq_species","n_pools")]
names(pc_neg)[3] <- "pools_negative"

pool_counts_wide <- merge(pc_conf, pc_neg, by = c("loc_year","mosq_species"), all = TRUE)
pool_counts_wide$pools_confirmed[is.na(pool_counts_wide$pools_confirmed)] <- 0
pool_counts_wide$pools_negative[is.na(pool_counts_wide$pools_negative)]   <- 0

## 4) Join: host × (confirmed/negative) per key; keep ALL host_species
counts <- merge(
  host_counts,
  pool_counts_wide,
  by = c("loc_year","mosq_species"),
  all.x = TRUE
)

## replace NAs for pool counts with 0 (keys with blood meals but no pools)
counts$pools_confirmed[is.na(counts$pools_confirmed)] <- 0
counts$pools_negative[is.na(counts$pools_negative)]   <- 0

## check
head(counts)

sum(counts$n_bloodmeals)  

```

## Wide format counts

For CCA (or RDA, PERMANOVA, etc.) you want the host species as separate
columns, one per species, with counts filled in (0 if absent). That way
you have a site × time × mosquito species matrix of bird hosts.

```{r count-wide}
## 1) Bloodmeal counts: wide by host species
host_counts <- aggregate(
  x = list(n_bloodmeals = rep(1, nrow(blood))),
  by = list(
    loc_year = blood$loc_year,
    mosq_species   = blood$mosq_species,
    host_common   = blood$host_common
  ),
  FUN = sum
)

## reshape wide: each host_species becomes its own column
host_counts_wide <- reshape(
  host_counts,
  idvar   = c("loc_year","mosq_species"),
  timevar = "host_common",
  direction = "wide"
)

## clean names: host_species -> host_xxx
names(host_counts_wide) <- sub("^n_bloodmeals\\.", "host_", names(host_counts_wide))

## replace NAs with 0 (no samples of that host at that site/month/species)
host_counts_wide[is.na(host_counts_wide)] <- 0

## 2) Pool counts: confirmed/negative (same as before)
pool_counts_long <- aggregate(
  x = list(n_pools = rep(1, nrow(pools))),
  by = list(
    loc_year = pools$loc_year,
    mosq_species   = pools$mosq_species,
    test_status    = pools$test_status
  ),
  FUN = sum
)

pc_conf <- subset(pool_counts_long, test_status == "Confirmed")[, c("loc_year","mosq_species","n_pools")]
names(pc_conf)[3] <- "pools_confirmed"

pc_neg <- subset(pool_counts_long, test_status == "Negative")[, c("loc_year","mosq_species","n_pools")]
names(pc_neg)[3] <- "pools_negative"

pool_counts_wide <- merge(pc_conf, pc_neg, by = c("loc_year","mosq_species"), all = TRUE)
pool_counts_wide$pools_confirmed[is.na(pool_counts_wide$pools_confirmed)] <- 0
pool_counts_wide$pools_negative[is.na(pool_counts_wide$pools_negative)]   <- 0

## 3) Final join: host × pools
counts_matrix <- merge(
  host_counts_wide,
  pool_counts_wide,
  by = c("loc_year","mosq_species"),
  all = TRUE
)

## replace NAs with 0 after join
counts_matrix[is.na(counts_matrix)] <- 0

# Did I loose any host data?
# Identify host columns (everything starting with "host_")
host_cols <- grep("^host_", names(counts_matrix))

# Sum all host counts across the matrix
sum(counts_matrix[ , host_cols])

# add a column for location specific positives:
# Compute whether any positives occurred at each site×year
loc_pos <- aggregate(
  pools_confirmed ~ loc_year,
  counts_matrix,
  function(x) as.integer(sum(x) > 0)
)
names(loc_pos)[2] <- "loc_positives"

# Join back into your main matrix
counts_matrix <- merge(counts_matrix, loc_pos, by = "loc_year", all.x = TRUE)

# Quick check
table(counts_matrix$loc_positives)  # 0 = no positives that year; 1 = at least one positive

# Also estimate the location positivity rate
counts_matrix$loc_rate <- counts_matrix$pools_confirmed/(counts_matrix$pools_confirmed + counts_matrix$pools_negative)

#add back in lat/long

## Save
out_file <- "./data/overlap_bloodmeal_WNV_counts_byYear_pip_tar.csv"
write.csv(counts_matrix, out_file, row.names = FALSE)

## Save final file for class analysis
out_file <- "./bloodmeal_plusWNV_for_BIOL3070.csv"
write.csv(counts_matrix, out_file, row.names = FALSE)
```

# Barplots

## Horizontal plots
```{r horiz-plot,fig.align='left',fig.width=7,fig.height=7, warning=FALSE}
## import counts_matrix: data.frame with column 'loc_positives' (0/1) and host columns 'host_*'
counts_matrix <- read.csv("./bloodmeal_plusWNV_for_BIOL3070.csv")

## 1) Identify host columns
host_cols <- grep("^host_", names(counts_matrix), value = TRUE)

if (length(host_cols) == 0) {
  stop("No columns matching '^host_' were found in counts_matrix.")
}

## 2) Ensure loc_positives is present and has both levels 0 and 1 where possible
counts_matrix$loc_positives <- factor(counts_matrix$loc_positives, levels = c(0, 1))

## 3) Aggregate host counts by loc_positives
agg <- stats::aggregate(
  counts_matrix[, host_cols, drop = FALSE],
  by = list(loc_positives = counts_matrix$loc_positives),
  FUN = function(x) sum(as.numeric(x), na.rm = TRUE)
)

## make sure both rows exist; if one is missing, add a zero row
need_levels <- setdiff(levels(counts_matrix$loc_positives), as.character(agg$loc_positives))
if (length(need_levels)) {
  zero_row <- as.list(rep(0, length(host_cols)))
  names(zero_row) <- host_cols
  for (lv in need_levels) {
    agg <- rbind(agg, c(lv, zero_row))
  }
  ## restore proper type
  agg$loc_positives <- factor(agg$loc_positives, levels = c("0","1"))
  ## coerce numeric host cols (they may have become character after rbind)
  for (hc in host_cols) agg[[hc]] <- as.numeric(agg[[hc]])
  agg <- agg[order(agg$loc_positives), , drop = FALSE]
}

## 4) Decide species order (overall abundance, descending)
overall <- colSums(agg[, host_cols, drop = FALSE], na.rm = TRUE)
host_order <- names(sort(overall, decreasing = TRUE))
species_labels <- rev(sub("^host_", "", host_order))  # nicer labels

## 5) Build count vectors for each panel in the SAME order
counts0 <- rev(as.numeric(agg[agg$loc_positives == 0, host_order, drop = TRUE]))
counts1 <- rev(as.numeric(agg[agg$loc_positives == 1, host_order, drop = TRUE]))

## 6) Colors: reuse your existing 'cols' if it exists and is long enough; otherwise generate
if (exists("cols") && length(cols) >= length(host_order)) {
  species_colors <- setNames(cols[seq_along(host_order)], species_labels)
} else {
  species_colors <- setNames(rainbow(length(host_order) + 10)[seq_along(host_order)], species_labels)
}

## 7) Shared x-limit for comparability
xmax <- max(c(counts0, counts1), na.rm = TRUE)
xmax <- if (is.finite(xmax)) xmax else 1
xlim_use <- c(0, xmax * 1.08)

## 8) Plot: two horizontal barplots with identical order and colors
op <- par(mfrow = c(1, 2),
          mar = c(4, 12, 3, 2),  # big left margin for species names
          xaxs = "i")           # a bit tighter axis padding

## Panel A: No WNV detected (loc_positives = 0)
barplot(height = counts0,
        names.arg = species_labels, 
        cex.names = .5,
        cex.axis = .5,
        col = rev(unname(species_colors[species_labels])),
        horiz = TRUE,
        las = 1,
        xlab = "Bloodmeal counts",
        main = "Locations WNV negative (-)",
        xlim = xlim_use)

## Panel B: WNV detected (loc_positives = 1)
barplot(height = counts1,
        names.arg = species_labels, 
        cex.names = .5,
        cex.axis = .5,
        col = rev(unname(species_colors[species_labels])),
        horiz = TRUE,
        las = 1,
        xlab = "Bloodmeal counts",
        main = "Locations WNV positive (+)",
        xlim = xlim_use)

par(op)

## Keep the colors mapping for reuse elsewhere
host_species_colors <- species_colors
```

# GLM: Generalized Linear Modeling

## House finch GLM

Does house finch have an effect by location positive +/- (binary)? by location positivity rate? YES.

```{r}
#glm with house finch alone against binary +/_
glm1 <- glm(loc_positives ~ host_House_finch,
            data = counts_matrix,
            family = binomial)
summary(glm1)

#glm with house-finch alone against positivity rate
glm2 <- glm(loc_rate ~ host_House_finch,
            data = counts_matrix)
summary(glm2)
```

## Song Sparrow GLM

Does song sparrow have an effect? Not enough sample size.
```{r}
#glm with song sparrow alone against binary +/_
glm3 <- glm(loc_positives ~ host_Song_sparrow,
            data = counts_matrix,
            family = binomial)
summary(glm3)

#glm with song sparrow alone against positivity rate
glm4 <- glm(loc_rate ~ host_Song_sparrow,
            data = counts_matrix)
summary(glm4)
```



# NOTE: I would explore host/mosquito species in pool a little more...

But... we can't without more Cx. tarsalis bloodmeal data, because... Every bloodmeal observation in overlap is being “tagged” with the species from the pools at that site × year. Without more data, we can't tell if the bloodmeal mosquito species may not actually be that species at all — we're borrowing the label from the pools.

Since we only have 11-ish Cx. tarsalis in the bloodmeal data, the rest is Cx. pipiens sl., maybe we should focus on the part of each dataset that is Cx. pipiens for any host effect.

TO improve sample size, maybe we should drop up a taxonomic level of the host ID to family/order.


# Heatmaps
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

hm <- counts_matrix %>%
  select(long, lat, loc_rate, host_House_finch) %>%
  mutate(across(c(loc_rate, host_House_finch), ~ ifelse(is.na(.), 0, .))) %>%
  pivot_longer(c(loc_rate, host_House_finch),
               names_to = "metric", values_to = "value")

ggplot(hm, aes(lon, lat, fill = value)) +
  geom_tile(width = 0.01, height = 0.01) +
  coord_equal() +
  facet_wrap(~ metric, nrow = 1,
             labeller = as_labeller(c(loc_rate = "WNV-positive pools (rate)",
                                      host_House_finch = "House finch blood meals"))) +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(fill = "Value", x = NULL, y = NULL)
```

