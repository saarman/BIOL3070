---
title: "Find Overlap: \n WNV Pools & Bloodmeal Datasets"
author: "Norah Saarman"
date: "Sep 9-11, 2025"
output:
  github_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# PIP ONLY

Cx_pipiens_sl only, dropping other data

## Pip - Bloodmeal COi Sequences pipiens only

```{r blood-pip}
blood_raw <- read.csv("../data/bloodmeal_for_BIOL3070.csv", stringsAsFactors = FALSE)

blood <- data.frame(
  date           = as.Date(blood_raw$Collection.Date, 
                           tryFormats = c("%Y-%m-%d","%m/%d/%Y")),
  year           = blood_raw$year,
  month          = blood_raw$month,
  lat            = blood_raw$Lat,
  long           = blood_raw$Long,
  loc_name       = blood_raw$Location,
  loc_code       = blood_raw$site_code,
  loc_year_month = blood_raw$loc_year_month,
  mosq_species   = blood_raw$mosq_species,
  host_species   = blood_raw$host_species,
  host_common   = blood_raw$host_common,
  host_method   = blood_raw$host_method,
  BIOL3070_seqID = blood_raw$SEQ..BIOL3070
)

# Drop Cx_erythrothorax and Cx_tarsalis
blood <- subset(blood, mosq_species != "Cx_erythrothorax")
blood <- subset(blood, mosq_species != "Cx_tarsalis")

head(blood)
```

## Pip - WNV test status by mosquito pool

```{r pools-pip}
pools_raw <- read.csv("../data/mosquito_pools_WNV.csv", stringsAsFactors = FALSE)

pools <- data.frame(
  agency_pool_num = pools_raw$agency_pool_num,
  mosq_species    = pools_raw$mosq_species,
  num_count       = pools_raw$num_count,
  date            = as.Date(pools_raw$collection_date, 
                            tryFormats = c("%Y-%m-%d","%m/%d/%Y")),
  year            = pools_raw$year,
  month           = pools_raw$month,
  lat             = pools_raw$longitude,
  long            = pools_raw$latitude,
  loc_code        = pools_raw$site_code,
  loc_name        = pools_raw$site_name,
  loc_year_month = pools_raw$loc_year_month,
  test_status     = pools_raw$test_status
)

# Drop Cx_erythrothorax and Cx_tarsalis
blood <- subset(blood, mosq_species != "Cx_erythrothorax")
blood <- subset(blood, mosq_species != "Cx_tarsalis")

head(pools)
```

## Pip - Overlap by loc_year_month

```{r overlap-pip}
# Inner join by loc_year_month
overlap <- merge(
  blood,
  pools,
  by = c("loc_year_month")
)

head(overlap); str(overlap); nrow(overlap)

# Add taxonomy to table
library(taxize)
overlap$species <- gsub("_", " ", overlap$host_species)
species_names <- unique(overlap$species)

get_tax <- function(sp) {
  x <- try(classification(sp, db = "gbif")[[1]], silent = TRUE)
  if (inherits(x, "try-error") || is.null(x)) return(NULL)
  x$rank <- tolower(x$rank)
  pick <- function(rk) {
    v <- x$name[x$rank == rk]
    if (length(v) > 0) v[1] else NA
  }
  data.frame(
    species = sp,
    genus   = pick("genus"),
    family  = pick("family"),
    order   = pick("order"),
    class   = pick("class"),
    stringsAsFactors = FALSE
  )
}

tax_table <- do.call(rbind, lapply(species_names, get_tax))

# join back to overlap
overlap <- merge(overlap, tax_table, by = "species", all.x = TRUE)
head(overlap[c("host_species","species","genus","family","order","class")])



write.csv(overlap, "../data/overlap_bloodmeal_WNV_byYearMo_pip_only.csv", row.names = FALSE)


```

## Pip - Collapse to counts

Host species, and counts of confirmed/negative WNV pools by
loc_year_month.

### Pip - Narrow format only one host_species column...

```{r counts-pip}
## 1) Bloodmeal counts: host species per key
host_counts <- aggregate(
  x = list(n_bloodmeals = rep(1, nrow(blood))),
  by = list(
    loc_year_month = blood$loc_year_month,
    mosq_species   = blood$mosq_species,
    host_common   = blood$host_common
  ),
  FUN = sum
)

## 2) WNV pool counts: test status per key
pool_counts_long <- aggregate(
  x = list(n_pools = rep(1, nrow(pools))),
  by = list(
    loc_year_month = pools$loc_year_month,
    mosq_species   = pools$mosq_species,
    test_status    = pools$test_status
  ),
  FUN = sum
)

## 3) Make Confirmed/Negative columns (keep both; fill missing with 0)
pc_conf <- subset(pool_counts_long, test_status == "Confirmed")[, c("loc_year_month","mosq_species","n_pools")]
names(pc_conf)[3] <- "pools_confirmed"

pc_neg  <- subset(pool_counts_long, test_status == "Negative")[, c("loc_year_month","mosq_species","n_pools")]
names(pc_neg)[3] <- "pools_negative"

pool_counts_wide <- merge(pc_conf, pc_neg, by = c("loc_year_month","mosq_species"), all = TRUE)
pool_counts_wide$pools_confirmed[is.na(pool_counts_wide$pools_confirmed)] <- 0
pool_counts_wide$pools_negative[is.na(pool_counts_wide$pools_negative)]   <- 0

## 4) Join: host × (confirmed/negative) per key; keep ALL host_species
counts <- merge(
  host_counts,
  pool_counts_wide,
  by = c("loc_year_month","mosq_species"),
  all.x = TRUE
)

## replace NAs for pool counts with 0 (keys with blood meals but no pools)
counts$pools_confirmed[is.na(counts$pools_confirmed)] <- 0
counts$pools_negative[is.na(counts$pools_negative)]   <- 0

## check
head(counts)

sum(counts$n_bloodmeals)  

```

### Pip - Wide format counts

For CCA (or RDA, PERMANOVA, etc.) you want the host species as separate
columns, one per species, with counts filled in (0 if absent). That way
you have a site × time × mosquito species matrix of bird hosts.

```{r count-wide-pip}
## 1) Bloodmeal counts: wide by host species
host_counts <- aggregate(
  x = list(n_bloodmeals = rep(1, nrow(blood))),
  by = list(
    loc_year_month = blood$loc_year_month,
    mosq_species   = blood$mosq_species,
    host_common   = blood$host_common
  ),
  FUN = sum
)

## reshape wide: each host_species becomes its own column
host_counts_wide <- reshape(
  host_counts,
  idvar   = c("loc_year_month","mosq_species"),
  timevar = "host_common",
  direction = "wide"
)

## clean names: host_species -> host_xxx
names(host_counts_wide) <- sub("^n_bloodmeals\\.", "host_", names(host_counts_wide))

## replace NAs with 0 (no samples of that host at that site/month/species)
host_counts_wide[is.na(host_counts_wide)] <- 0

## 2) Pool counts: confirmed/negative (same as before)
pool_counts_long <- aggregate(
  x = list(n_pools = rep(1, nrow(pools))),
  by = list(
    loc_year_month = pools$loc_year_month,
    mosq_species   = pools$mosq_species,
    test_status    = pools$test_status
  ),
  FUN = sum
)

pc_conf <- subset(pool_counts_long, test_status == "Confirmed")[, c("loc_year_month","mosq_species","n_pools")]
names(pc_conf)[3] <- "pools_confirmed"

pc_neg <- subset(pool_counts_long, test_status == "Negative")[, c("loc_year_month","mosq_species","n_pools")]
names(pc_neg)[3] <- "pools_negative"

pool_counts_wide <- merge(pc_conf, pc_neg, by = c("loc_year_month","mosq_species"), all = TRUE)
pool_counts_wide$pools_confirmed[is.na(pool_counts_wide$pools_confirmed)] <- 0
pool_counts_wide$pools_negative[is.na(pool_counts_wide$pools_negative)]   <- 0

## 3) Final join: host × pools
counts_matrix <- merge(
  host_counts_wide,
  pool_counts_wide,
  by = c("loc_year_month","mosq_species"),
  all = TRUE
)

## replace NAs with 0 after join
counts_matrix[is.na(counts_matrix)] <- 0

# Did I loose any host data?
# Identify host columns (everything starting with "host_")
host_cols <- grep("^host_", names(counts_matrix))

# Sum all host counts across the matrix
sum(counts_matrix[ , host_cols])

# add a column for location specific positives:
# Compute whether any positives occurred at each site×month
loc_pos <- aggregate(
  pools_confirmed ~ loc_year_month,
  counts_matrix,
  function(x) as.integer(sum(x) > 0)
)
names(loc_pos)[2] <- "loc_positives"

# Join back into your main matrix
counts_matrix <- merge(counts_matrix, loc_pos, by = "loc_year_month", all.x = TRUE)

# Quick check
table(counts_matrix$loc_positives)  # 0 = no positives that month; 1 = at least one positive

## Save
out_file <- "../data/overlap_bloodmeal_WNV_counts_byYearMo_pip_only.csv"
write.csv(counts_matrix, out_file, row.names = FALSE)
```

## Pip - Stacked barplot of host composition by loc_positives (0 vs 1)

```{r barplot-pip,fig.align='left',fig.width=7,fig.height=7, warning=FALSE}
## 1) Identify host columns
host_cols <- grep("^host_", names(counts_matrix), value = TRUE)

## 2) Aggregate host counts by loc_positives (0/1)
agg <- aggregate(counts_matrix[, host_cols, drop = FALSE],
                 by = list(loc_positives = counts_matrix$loc_positives),
                 FUN = sum)

## ensure order is 0,1 if both exist
agg <- agg[order(agg$loc_positives), , drop = FALSE]

## 3) Order host columns by overall abundance for a nicer legend
totals <- colSums(agg[, host_cols, drop = FALSE])
host_order <- names(sort(totals, decreasing = TRUE))

## 4) Build matrices for plotting
mat_counts <- t(as.matrix(agg[, host_order, drop = FALSE]))  # rows=hosts, cols=loc_positives groups
colnames(mat_counts) <- paste0("loc_positives=", agg$loc_positives)

## 5) Colors and labels
n_hosts <- nrow(mat_counts)
cols <- rainbow(n_hosts+10)
leg_labs <- sub("^host_", "", rownames(mat_counts))  # cleaner legend labels

mat_counts

## 6a) Stacked barplot — COUNTS
op <- par(mar = c(5, 4, 2, 20))  # extra right margin for legend
barplot(mat_counts, beside = FALSE, col = cols,
        names.arg = c("0",">1"),
        ylab = "Bloodmeal counts",
        xlab = "Any WNV+ pools at site×month?")
legend("topright", inset = c(-0.78, 0), xpd = TRUE,
       legend = leg_labs, fill = cols, cex = 0.7)
par(op)

## 6b) (Optional) Stacked barplot — PROPORTIONS
mat_props <- apply(mat_counts, 2, function(x) if (sum(x) > 0) x / sum(x) else x)
op <- par(mar = c(5, 4, 2, 20))
barplot(mat_props, beside = FALSE, col = cols,
        names.arg = c("0",">1"),
        ylab = "Proportion of bloodmeals",
        xlab = "Any WNV+ pools at site×month?")
legend("topright", inset = c(-0.78, 0), xpd = TRUE,
       legend = leg_labs, fill = cols, cex = 0.7)
par(op)
```

## Pip - Fisher's Exact Tests

### Pip - House finch over-represented in locations with \>1 positive pool?

```{r finch-pip}
# Build 2x2 for House Finch
hf_table <- matrix(c(
  17,  # Finch in loc_positive=1
  78,  # Finch in loc_positive=0
  sum(counts_matrix$loc_positives) - 17,  # All other hosts in positive
  sum(1 - counts_matrix$loc_positives) - 78  # All other hosts in negative
), nrow = 2, byrow = TRUE)

fisher.test(hf_table)
```

### Pip - Song sparrow over-represented in locations with \>1 positive pool?

(I just happened to notice from the bar plot that it looks to be)...

```{r song-pip}
# Build 2x2 for Song Sparrow
ss_table <- matrix(c(
  4,  # Sparrow in loc_positive=1
  2,  # Sparrow in loc_positive=0
  sum(counts_matrix$loc_positives) - 4,
  sum(1 - counts_matrix$loc_positives) - 2
), nrow = 2, byrow = TRUE)

fisher.test(ss_table)
```

## Pip - GLM Song Sparrow

Does song sparrow have an effect in pip only data? Maybe?

```{r}
#glm with bird
glm1 <- glm(loc_positives ~ host_Song_sparrow,
            data = counts_matrix,
            family = binomial)
summary(glm1)
```

## Pip - GLM house finch

Does house finch have an effect in pip only data? NO.

```{r}
#glm with bird
glm1 <- glm(loc_positives ~ host_House_finch,
            data = counts_matrix,
            family = binomial)
summary(glm1)

```

# ALL DATA

All data available, pip and tars Uniting WNV and Bloodmeal COi Sequences

## PipTar - Bloodmeal COi Sequences

```{r blood}
blood_raw <- read.csv("../data/bloodmeal_for_BIOL3070.csv", stringsAsFactors = FALSE)

blood <- data.frame(
  date           = as.Date(blood_raw$Collection.Date, 
                           tryFormats = c("%Y-%m-%d","%m/%d/%Y")),
  year           = blood_raw$year,
  month          = blood_raw$month,
  lat            = blood_raw$Lat,
  long           = blood_raw$Long,
  loc_name       = blood_raw$Location,
  loc_code       = blood_raw$site_code,
  loc_year_month = blood_raw$loc_year_month,
  mosq_species   = blood_raw$mosq_species,
  host_species   = blood_raw$host_species,
  host_common   = blood_raw$host_common,
  host_method   = blood_raw$host_method,
  BIOL3070_seqID = blood_raw$SEQ..BIOL3070
)

# Drop Cx_erythrothorax
blood <- subset(blood, mosq_species != "Cx_erythrothorax")

head(blood)
```

## PipTar - WNV test status by mosquito pool

```{r pools}
pools_raw <- read.csv("../data/mosquito_pools_WNV.csv", stringsAsFactors = FALSE)

pools <- data.frame(
  agency_pool_num = pools_raw$agency_pool_num,
  mosq_species    = pools_raw$mosq_species,
  num_count       = pools_raw$num_count,
  date            = as.Date(pools_raw$collection_date, 
                            tryFormats = c("%Y-%m-%d","%m/%d/%Y")),
  year            = pools_raw$year,
  month           = pools_raw$month,
  lat             = pools_raw$longitude,
  long            = pools_raw$latitude,
  loc_code        = pools_raw$site_code,
  loc_name        = pools_raw$site_name,
  loc_year_month = pools_raw$loc_year_month,
  test_status     = pools_raw$test_status
)

# Drop Cx_erythrothorax
pools <- subset(pools, mosq_species != "Cx_erythrothorax")

head(pools)
```

## PipTar - Overlap by loc_year_month + mosq_species

```{r}
# Inner join by loc_year_month + mosq_species
overlap <- merge(
  blood,
  pools,
  by = c("loc_year_month", "mosq_species")
)

head(overlap); str(overlap); nrow(overlap)


# Add taxonomy to table
library(taxize)
overlap$species <- gsub("_", " ", overlap$host_species)
species_names <- unique(overlap$species)

get_tax <- function(sp) {
  x <- try(classification(sp, db = "gbif")[[1]], silent = TRUE)
  if (inherits(x, "try-error") || is.null(x)) return(NULL)
  x$rank <- tolower(x$rank)
  pick <- function(rk) {
    v <- x$name[x$rank == rk]
    if (length(v) > 0) v[1] else NA
  }
  data.frame(
    species = sp,
    genus   = pick("genus"),
    family  = pick("family"),
    order   = pick("order"),
    class   = pick("class"),
    stringsAsFactors = FALSE
  )
}

tax_table <- do.call(rbind, lapply(species_names, get_tax))

# join back to overlap
overlap <- merge(overlap, tax_table, by = "species", all.x = TRUE)
head(overlap[c("host_species","species","genus","family","order","class")])

# Write to file
write.csv(overlap, "../data/overlap_bloodmeal_WNV_byYearMo_pip_tar.csv", row.names = FALSE)
```

## PipTar - Collapse to counts

Host species, and counts of confirmed/negative WNV pools by
loc_year_month × mosq_species.

### PipTar - Narrow format only one host_species column...

```{r counts}
## 1) Bloodmeal counts: host species per key
host_counts <- aggregate(
  x = list(n_bloodmeals = rep(1, nrow(blood))),
  by = list(
    loc_year_month = blood$loc_year_month,
    mosq_species   = blood$mosq_species,
    host_common   = blood$host_common
  ),
  FUN = sum
)

## 2) WNV pool counts: test status per key
pool_counts_long <- aggregate(
  x = list(n_pools = rep(1, nrow(pools))),
  by = list(
    loc_year_month = pools$loc_year_month,
    mosq_species   = pools$mosq_species,
    test_status    = pools$test_status
  ),
  FUN = sum
)

## 3) Make Confirmed/Negative columns (keep both; fill missing with 0)
pc_conf <- subset(pool_counts_long, test_status == "Confirmed")[, c("loc_year_month","mosq_species","n_pools")]
names(pc_conf)[3] <- "pools_confirmed"

pc_neg  <- subset(pool_counts_long, test_status == "Negative")[, c("loc_year_month","mosq_species","n_pools")]
names(pc_neg)[3] <- "pools_negative"

pool_counts_wide <- merge(pc_conf, pc_neg, by = c("loc_year_month","mosq_species"), all = TRUE)
pool_counts_wide$pools_confirmed[is.na(pool_counts_wide$pools_confirmed)] <- 0
pool_counts_wide$pools_negative[is.na(pool_counts_wide$pools_negative)]   <- 0

## 4) Join: host × (confirmed/negative) per key; keep ALL host_species
counts <- merge(
  host_counts,
  pool_counts_wide,
  by = c("loc_year_month","mosq_species"),
  all.x = TRUE
)

## replace NAs for pool counts with 0 (keys with blood meals but no pools)
counts$pools_confirmed[is.na(counts$pools_confirmed)] <- 0
counts$pools_negative[is.na(counts$pools_negative)]   <- 0

## check
head(counts)

sum(counts$n_bloodmeals)  

```

### PipTar - Wide format counts

For CCA (or RDA, PERMANOVA, etc.) you want the host species as separate
columns, one per species, with counts filled in (0 if absent). That way
you have a site × time × mosquito species matrix of bird hosts.

```{r count-wide}
## 1) Bloodmeal counts: wide by host species
host_counts <- aggregate(
  x = list(n_bloodmeals = rep(1, nrow(blood))),
  by = list(
    loc_year_month = blood$loc_year_month,
    mosq_species   = blood$mosq_species,
    host_common   = blood$host_common
  ),
  FUN = sum
)

## reshape wide: each host_species becomes its own column
host_counts_wide <- reshape(
  host_counts,
  idvar   = c("loc_year_month","mosq_species"),
  timevar = "host_common",
  direction = "wide"
)

## clean names: host_species -> host_xxx
names(host_counts_wide) <- sub("^n_bloodmeals\\.", "host_", names(host_counts_wide))

## replace NAs with 0 (no samples of that host at that site/month/species)
host_counts_wide[is.na(host_counts_wide)] <- 0

## 2) Pool counts: confirmed/negative (same as before)
pool_counts_long <- aggregate(
  x = list(n_pools = rep(1, nrow(pools))),
  by = list(
    loc_year_month = pools$loc_year_month,
    mosq_species   = pools$mosq_species,
    test_status    = pools$test_status
  ),
  FUN = sum
)

pc_conf <- subset(pool_counts_long, test_status == "Confirmed")[, c("loc_year_month","mosq_species","n_pools")]
names(pc_conf)[3] <- "pools_confirmed"

pc_neg <- subset(pool_counts_long, test_status == "Negative")[, c("loc_year_month","mosq_species","n_pools")]
names(pc_neg)[3] <- "pools_negative"

pool_counts_wide <- merge(pc_conf, pc_neg, by = c("loc_year_month","mosq_species"), all = TRUE)
pool_counts_wide$pools_confirmed[is.na(pool_counts_wide$pools_confirmed)] <- 0
pool_counts_wide$pools_negative[is.na(pool_counts_wide$pools_negative)]   <- 0

## 3) Final join: host × pools
counts_matrix <- merge(
  host_counts_wide,
  pool_counts_wide,
  by = c("loc_year_month","mosq_species"),
  all = TRUE
)

## replace NAs with 0 after join
counts_matrix[is.na(counts_matrix)] <- 0

# Did I loose any host data?
# Identify host columns (everything starting with "host_")
host_cols <- grep("^host_", names(counts_matrix))

# Sum all host counts across the matrix
sum(counts_matrix[ , host_cols])

# add a column for location specific positives:
# Compute whether any positives occurred at each site×month
loc_pos <- aggregate(
  pools_confirmed ~ loc_year_month,
  counts_matrix,
  function(x) as.integer(sum(x) > 0)
)
names(loc_pos)[2] <- "loc_positives"

# Join back into your main matrix
counts_matrix <- merge(counts_matrix, loc_pos, by = "loc_year_month", all.x = TRUE)

# Quick check
table(counts_matrix$loc_positives)  # 0 = no positives that month; 1 = at least one positive

## Save
out_file <- "../data/overlap_bloodmeal_WNV_counts_byYearMo_pip_tar.csv"
write.csv(counts_matrix, out_file, row.names = FALSE)
```

## PipTar - Stacked barplot of host composition by loc_positives (0 vs 1)

```{r, ,fig.align='left',fig.width=7,fig.height=7, warning=FALSE}
## 1) Identify host columns
host_cols <- grep("^host_", names(counts_matrix), value = TRUE)

## 2) Aggregate host counts by loc_positives (0/1)
agg <- aggregate(counts_matrix[, host_cols, drop = FALSE],
                 by = list(loc_positives = counts_matrix$loc_positives),
                 FUN = sum)

## ensure order is 0,1 if both exist
agg <- agg[order(agg$loc_positives), , drop = FALSE]

## 3) Order host columns by overall abundance for a nicer legend
totals <- colSums(agg[, host_cols, drop = FALSE])
host_order <- names(sort(totals, decreasing = TRUE))

## 4) Build matrices for plotting
mat_counts <- t(as.matrix(agg[, host_order, drop = FALSE]))  # rows=hosts, cols=loc_positives groups
colnames(mat_counts) <- paste0("loc_positives=", agg$loc_positives)

## 5) Colors and labels
n_hosts <- nrow(mat_counts)
cols <- rainbow(n_hosts+10)
leg_labs <- sub("^host_", "", rownames(mat_counts))  # cleaner legend labels

mat_counts

## 6a) Stacked barplot — COUNTS
op <- par(mar = c(5, 4, 2, 20))  # extra right margin for legend
barplot(mat_counts, beside = FALSE, col = cols,
        names.arg = c("0",">1"),
        ylab = "Bloodmeal counts",
        xlab = "Any WNV+ pools at site×month?")
legend("topright", inset = c(-0.78, 0), xpd = TRUE,
       legend = leg_labs, fill = cols, cex = 0.7)
par(op)

## 6b) (Optional) Stacked barplot — PROPORTIONS
mat_props <- apply(mat_counts, 2, function(x) if (sum(x) > 0) x / sum(x) else x)
op <- par(mar = c(5, 4, 2, 20))
barplot(mat_props, beside = FALSE, col = cols,
        names.arg = c("0",">1"),
        ylab = "Proportion of bloodmeals",
        xlab = "Any WNV+ pools at site×month?")
legend("topright", inset = c(-0.78, 0), xpd = TRUE,
       legend = leg_labs, fill = cols, cex = 0.7)
par(op)
```

## PipTar - Fisher's Exact Tests

### PipTar - House finch over-represented in locations with \>1 positive pool?

```{r finch}
# Build 2x2 for House Finch
hf_table <- matrix(c(
  17,  # Finch in loc_positive=1
  80,  # Finch in loc_positive=0
  sum(counts_matrix$loc_positives) - 17,  # All other hosts in positive
  sum(1 - counts_matrix$loc_positives) - 80  # All other hosts in negative
), nrow = 2, byrow = TRUE)

fisher.test(hf_table)
```

### PipTar - Song sparrow over-represented in locations with \>1 positive pool?

(I just happened to notice from the bar plot that it looks to be)...

```{r song}
# Build 2x2 for Song Sparrow
ss_table <- matrix(c(
  4,  # Sparrow in loc_positive=1
  2,  # Sparrow in loc_positive=0
  sum(counts_matrix$loc_positives) - 4,
  sum(1 - counts_matrix$loc_positives) - 2
), nrow = 2, byrow = TRUE)

fisher.test(ss_table)
```

### PipTar - Maybe its the mosquito? YES

If Song Sparrows show up mostly where Cx. tarsalis is sampled, then the
apparent “overrepresentation” could really be a mosquito-species effect
rather than a host effect... but see below in Cx_pipiens_sl only
dataset... the numbers are the same, and the Song Sparrow is even more
significant by Fisher's Exact test, so my logic is flawed. Yet, the
mosquito really does seem to play a big role! Does SLCMAD know that?

```{r}
# contingency table: mosquito species × loc_positives
tab_ms <- table(counts_matrix$mosq_species, counts_matrix$loc_positives)
tab_ms

# Fisher’s exact test
fisher.test(tab_ms)
```

The p-value (0.0025) is significant → the distribution of positives
differs between Cx. pipiens sl and Cx. tarsalis. The odds ratio \< 1
(0.65) means that Cx. tarsalis pools were less likely to be positive
compared to Cx. pipiens sl.

## GLM Mosquito (and Song Sparrow)

Does song sparrow have an effect after accounting for mosquito species
of the positive pool? MAYBE? Hard to say...No song sparrows in locations
with Cx. tarsalis positive pools, so we cannot test this yet.

```{r}
#glm with bird
glm1 <- glm(loc_positives ~ host_Song_sparrow,
            data = counts_matrix,
            family = binomial)
summary(glm1)

#glm with both
glm2 <- glm(loc_positives ~ host_Song_sparrow * mosq_species,
            data = counts_matrix,
            family = binomial)
summary(glm2)

#glm with mosquito only
glm2 <- glm(loc_positives ~ mosq_species,
            data = counts_matrix,
            family = binomial)
summary(glm2)
```

Nope...we don't have sample size, but this indicates mosq_species is the
more important indicator here!

GLM Mosquito species effect In all three models, the coefficient for
mosq_speciesCx_tarsalis is negative (around –0.42), with p-values
\~0.003. That means that, compared to the reference (Cx. pipiens sl),
the odds of seeing a positive at a site×month when the pools are Cx.
tarsalis are significantly lower. Converting the log-odds: exp(–0.42) ≈
0.66. That’s a \~34% reduction in odds of positivity relative to
pipiens. host_Song_sparrow effect

GLM song sparrow effect The coefficient for host_Song_sparrow is
positive (\~+1.03), which would mean more Song Sparrow bloodmeals →
higher odds of positives. But the p-value is 0.17, so the estimate is
not statistically significant given your data (and the low sample size
for sparrows).

GLM song sparrow x mosquito Interaction model In loc_positives \~
host_Song_sparrow \* mosq_species, the interaction term is NA. That
means there were no rows with enough variation to estimate “Song Sparrow
effect within tarsalis.” In other words, Song Sparrows only co-occur
with one mosquito species (probably pipiens), so the model can’t
separate the two.

Mosquito-only model Even without Song Sparrow in the model, mosq_species
stays significant. So the signal is really being driven by differences
between Cx. pipiens sl and Cx. tarsalis pools, not by Song Sparrow
counts.

## GLM Mosquito (and house finch)

Does house finch have an effect after accounting for mosquito species of
the positive pool? NO.

```{r}
#glm with bird
glm1 <- glm(loc_positives ~ host_House_finch,
            data = counts_matrix,
            family = binomial)
summary(glm1)

#glm with interactive effect
glm2 <- glm(loc_positives ~ host_House_finch * mosq_species,
            data = counts_matrix,
            family = binomial)
summary(glm2)

#glm with mosquito only
glm2 <- glm(loc_positives ~ mosq_species,
            data = counts_matrix,
            family = binomial)
summary(glm2)
```

### NOTE: I would explore host/mosquito species in pool a little more...

But... we can't without more Cx. tarsalis bloodmeal data, because... Every bloodmeal observation in overlap is being “tagged” with the species from the pools at that site × month.

But the bloodmeal mosquito species may not actually be that species at all — we're borrowing the label from the pools.

Since we only have 11-ish Cx. tarsalis in the bloodmeal data, the restis Cx. pipiens sl., maybe we should focus on the part of each datasetthat is Cx. pipiens for any host effect.

TO improve sample size, maybe we should drop up a taxonomic level to family/order.

